"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getForkedNetwork = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
async function default_1(args, hre, run) {
    if (hre.network.name === 'hardhat' && !args.fork)
        await runNormalTests(args, hre, run);
    else if (hre.network.name === 'hardhat' && args.fork)
        await runForkTests(args, hre, run);
    else
        await runDeployTests(args, hre, run);
}
exports.default = default_1;
async function runNormalTests(args, hre, run) {
    console.log('Running normal tests...');
    args.testFiles = args.testFiles.filter((file) => file.endsWith('.test.ts'));
    await run(args);
}
async function runDeployTests(args, hre, run) {
    console.log('Running deployment tests...');
    if (args.fork)
        throw Error("The 'fork' option is invalid when testing deployments on livenetwork");
    args.testFiles = args.testFiles.filter((file) => file.endsWith('.deploy.ts'));
    await run(args);
}
async function runForkTests(args, hre, run) {
    console.log('Running fork tests...');
    if (args.fork === 'hardhat')
        throw Error('Cannot fork local networks');
    args.testFiles = args.testFiles.filter((file) => file.endsWith('.fork.ts'));
    const forkingNetworkName = Object.keys(hre.config.networks).find((networkName) => networkName === args.fork);
    if (!forkingNetworkName)
        throw Error(`Could not find a config for network ${args.fork} to be forked`);
    const forkingNetworkConfig = hre.config.networks[forkingNetworkName];
    if (!forkingNetworkConfig.url)
        throw Error(`Could not find a RPC url in network config for ${forkingNetworkName}`);
    await hre.network.provider.request({
        method: 'hardhat_reset',
        params: [{ forking: { jsonRpcUrl: forkingNetworkConfig.url, blockNumber: args.blockNumber } }],
    });
    const config = hre.network.config;
    config.forking = { enabled: true, blockNumber: args.blockNumber, url: forkingNetworkConfig.url };
    await run(args);
}
function getForkedNetwork(hre) {
    const config = hre.network.config;
    if (!config.forking || !config.forking.url)
        throw Error(`No forks found on network ${hre.network.name}`);
    const network = Object.entries(hre.config.networks).find(([, networkConfig]) => {
        var _a;
        const httpNetworkConfig = networkConfig;
        return httpNetworkConfig.url && httpNetworkConfig.url === ((_a = config === null || config === void 0 ? void 0 : config.forking) === null || _a === void 0 ? void 0 : _a.url);
    });
    if (!network)
        throw Error(`No network found matching fork from ${config.forking.url}`);
    return network[0];
}
exports.getForkedNetwork = getForkedNetwork;
