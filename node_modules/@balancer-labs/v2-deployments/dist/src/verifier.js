"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const version_1 = require("@nomiclabs/hardhat-etherscan/dist/src/solc/version");
const ABIEncoder_1 = require("@nomiclabs/hardhat-etherscan/dist/src/ABIEncoder");
const libraries_1 = require("@nomiclabs/hardhat-etherscan/dist/src/solc/libraries");
const bytecode_1 = require("@nomiclabs/hardhat-etherscan/dist/src/solc/bytecode");
const prober_1 = require("@nomiclabs/hardhat-etherscan/dist/src/network/prober");
const EtherscanVerifyContractRequest_1 = require("@nomiclabs/hardhat-etherscan/dist/src/etherscan/EtherscanVerifyContractRequest");
const EtherscanService_1 = __importStar(require("@nomiclabs/hardhat-etherscan/dist/src/etherscan/EtherscanService"));
const logger_1 = __importDefault(require("./logger"));
const MAX_VERIFICATION_INTENTS = 3;
class Verifier {
    constructor(_network, _apiKey) {
        this.network = _network;
        this.apiKey = _apiKey;
    }
    async call(task, name, address, constructorArguments, libraries = {}, intent = 1) {
        const response = await this.verify(task, name, address, constructorArguments, libraries);
        if (response.isVerificationSuccess()) {
            const etherscanAPIEndpoints = await prober_1.getEtherscanEndpoints(this.network.provider, this.network.name);
            const contractURL = new URL(`/address/${address}#code`, etherscanAPIEndpoints.browserURL);
            return contractURL.toString();
        }
        else if (intent < MAX_VERIFICATION_INTENTS && response.isBytecodeMissingInNetworkError()) {
            logger_1.default.info(`Could not find deployed bytecode in network, retrying ${intent++}/${MAX_VERIFICATION_INTENTS}...`);
            EtherscanService_1.delay(5000);
            return this.call(task, name, address, constructorArguments, libraries, intent++);
        }
        else {
            throw new Error(`The contract verification failed. Reason: ${response.message}`);
        }
    }
    async verify(task, name, address, args, libraries = {}) {
        const deployedBytecodeHex = await prober_1.retrieveContractBytecode(address, this.network.provider, this.network.name);
        const deployedBytecode = new bytecode_1.Bytecode(deployedBytecodeHex);
        const buildInfos = await task.buildInfos();
        const buildInfo = this.findBuildInfoWithContract(buildInfos, name);
        const sourceName = this.findContractSourceName(buildInfo, name);
        const contractInformation = await bytecode_1.extractMatchingContractInformation(sourceName, name, buildInfo, deployedBytecode);
        if (!contractInformation)
            throw Error('Could not find a bytecode matching the requested contract');
        const { libraryLinks } = await libraries_1.getLibraryLinks(contractInformation, libraries);
        contractInformation.libraryLinks = libraryLinks;
        const deployArgumentsEncoded = typeof args == 'string'
            ? args
            : await ABIEncoder_1.encodeArguments(contractInformation.contract.abi, contractInformation.sourceName, contractInformation.contractName, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            args);
        const solcFullVersion = await version_1.getLongVersion(contractInformation.solcVersion);
        const etherscanAPIEndpoints = await prober_1.getEtherscanEndpoints(this.network.provider, this.network.name);
        const minimumBuildVerificationStatus = await this.attemptVerification(etherscanAPIEndpoints, contractInformation, address, this.apiKey, buildInfo.input, solcFullVersion, deployArgumentsEncoded);
        if (minimumBuildVerificationStatus.isVerificationSuccess())
            return minimumBuildVerificationStatus;
        const verificationStatus = await this.attemptVerification(etherscanAPIEndpoints, contractInformation, address, this.apiKey, contractInformation.compilerInput, solcFullVersion, deployArgumentsEncoded);
        if (verificationStatus.isVerificationSuccess())
            return verificationStatus;
        throw new Error(`The contract verification failed. Reason: ${verificationStatus.message}`);
    }
    async attemptVerification(etherscanAPIEndpoints, contractInformation, contractAddress, etherscanAPIKey, compilerInput, solcFullVersion, deployArgumentsEncoded) {
        compilerInput.settings.libraries = contractInformation.libraryLinks;
        const request = EtherscanVerifyContractRequest_1.toVerifyRequest({
            apiKey: etherscanAPIKey,
            contractAddress,
            sourceCode: JSON.stringify(compilerInput),
            sourceName: contractInformation.sourceName,
            contractName: contractInformation.contractName,
            compilerVersion: solcFullVersion,
            constructorArguments: deployArgumentsEncoded,
        });
        const response = await this.verifyContract(etherscanAPIEndpoints.apiURL, request);
        const pollRequest = EtherscanVerifyContractRequest_1.toCheckStatusRequest({ apiKey: etherscanAPIKey, guid: response.message });
        await EtherscanService_1.delay(700);
        const verificationStatus = await EtherscanService_1.getVerificationStatus(etherscanAPIEndpoints.apiURL, pollRequest);
        if (verificationStatus.isVerificationFailure() || verificationStatus.isVerificationSuccess()) {
            return verificationStatus;
        }
        throw new Error(`The API responded with an unexpected message: ${verificationStatus.message}`);
    }
    async verifyContract(url, req) {
        const parameters = new URLSearchParams({ ...req });
        const requestDetails = { method: 'post', body: parameters };
        let response;
        try {
            response = await node_fetch_1.default(url, requestDetails);
        }
        catch (error) {
            throw Error(`Failed to send verification request. Reason: ${error.message}`);
        }
        if (!response.ok) {
            const responseText = await response.text();
            throw Error(`Failed to send verification request.\nHTTP code: ${response.status}.\nResponse: ${responseText}`);
        }
        const etherscanResponse = new EtherscanService_1.default(await response.json());
        if (!etherscanResponse.isOk())
            throw Error(etherscanResponse.message);
        return etherscanResponse;
    }
    findBuildInfoWithContract(buildInfos, contractName) {
        const found = buildInfos.find((buildInfo) => this.getAllFullyQualifiedNames(buildInfo).some((name) => name.contractName === contractName));
        if (found === undefined) {
            throw Error(`Could not find a build info for contract ${contractName}`);
        }
        else {
            return found;
        }
    }
    findContractSourceName(buildInfo, contractName) {
        const names = this.getAllFullyQualifiedNames(buildInfo);
        const contractMatches = names.filter((name) => name.contractName === contractName);
        if (contractMatches.length === 0)
            throw Error('Could not find a bytecode matching the requested contract');
        if (contractMatches.length > 1)
            throw Error('More than one contract was found to match the deployed bytecode');
        return contractMatches[0].sourceName;
    }
    getAllFullyQualifiedNames(buildInfo) {
        const contracts = buildInfo.output.contracts;
        return Object.keys(contracts).reduce((names, sourceName) => {
            const contractsNames = Object.keys(contracts[sourceName]);
            const qualifiedNames = contractsNames.map((contractName) => ({ sourceName, contractName }));
            return names.concat(qualifiedNames);
        }, []);
    }
}
exports.default = Verifier;
