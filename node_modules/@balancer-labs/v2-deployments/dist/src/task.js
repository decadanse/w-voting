"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importStar(require("path"));
const ethers_1 = require("ethers");
const logger_1 = __importDefault(require("./logger"));
const contracts_1 = require("./contracts");
const types_1 = require("./types");
const TASKS_DIRECTORY = path_1.default.resolve(__dirname, '../tasks');
/* eslint-disable @typescript-eslint/no-var-requires */
class Task {
    constructor(id, network, verifier) {
        if (network && !types_1.NETWORKS.includes(network))
            throw Error(`Unknown network ${network}`);
        this.id = id;
        this._network = network;
        this._verifier = verifier;
    }
    static fromHRE(id, hre, verifier) {
        return new this(id, hre.network.name, verifier);
    }
    static forTest(id, network, outputTestFile = 'test') {
        const task = new this(id, network);
        task.outputFile = outputTestFile;
        return task;
    }
    get outputFile() {
        return `${this._outputFile || this.network}.json`;
    }
    set outputFile(file) {
        this._outputFile = file;
    }
    get network() {
        if (!this._network)
            throw Error('A network must be specified to define a task');
        return this._network;
    }
    set network(name) {
        this._network = name;
    }
    async instanceAt(name, address) {
        return contracts_1.instanceAt(this.artifact(name), address);
    }
    async deployedInstance(name) {
        const address = this.output()[name];
        if (!address)
            throw Error(`Could not find deployed address for ${name}`);
        return this.instanceAt(name, address);
    }
    async inputInstance(artifactName, inputName) {
        const rawInput = this.rawInput();
        const input = rawInput[inputName];
        if (!this._isTask(input))
            throw Error(`Cannot access to non-task input ${inputName}`);
        const task = input;
        task.network = this.network;
        const address = this._parseRawInput(rawInput)[inputName];
        return task.instanceAt(artifactName, address);
    }
    async deployAndVerify(name, args = [], from, force, libs) {
        const output = this.output({ ensure: false });
        if (force || !output[name]) {
            const instance = await this.deploy(name, args, from, libs);
            this.save({ [name]: instance });
            await this.verify(name, instance.address, args, libs);
            return instance;
        }
        else {
            logger_1.default.info(`${name} already deployed at ${output[name]}`);
            await this.verify(name, output[name], args, libs);
            return this.instanceAt(name, output[name]);
        }
    }
    async deploy(name, args = [], from, libs) {
        const instance = await contracts_1.deploy(this.artifact(name), args, from, libs);
        logger_1.default.success(`Deployed ${name} at ${instance.address}`);
        return instance;
    }
    async verify(name, address, constructorArguments, libs) {
        try {
            if (!this._verifier)
                return logger_1.default.warn('Skipping contract verification, no verifier defined');
            const url = await this._verifier.call(this, name, address, constructorArguments, libs);
            logger_1.default.success(`Verified contract ${name} at ${url}`);
        }
        catch (error) {
            logger_1.default.error(`Failed trying to verify ${name} at ${address}: ${error}`);
        }
    }
    async run(options = {}) {
        const taskPath = this._fileAt(this.dir(), 'index.ts');
        const task = require(taskPath).default;
        await task(this, options);
    }
    dir() {
        if (!this.id)
            throw Error('Please provide a task deployment ID to run');
        return this._dirAt(TASKS_DIRECTORY, this.id);
    }
    buildInfo(fileName) {
        const buildInfoDir = this._dirAt(this.dir(), 'build-info');
        const artifactFile = this._fileAt(buildInfoDir, `${path_1.extname(fileName) ? fileName : `${fileName}.json`}`);
        return JSON.parse(fs_1.default.readFileSync(artifactFile).toString());
    }
    buildInfos() {
        const buildInfoDir = this._dirAt(this.dir(), 'build-info');
        return fs_1.default.readdirSync(buildInfoDir).map((fileName) => this.buildInfo(fileName));
    }
    artifact(contractName, fileName) {
        const buildInfoDir = this._dirAt(this.dir(), 'build-info');
        const builds = this._existsFile(path_1.default.join(buildInfoDir, `${fileName || contractName}.json`))
            ? this.buildInfo(contractName).output.contracts
            : this.buildInfos().reduce((result, info) => ({ ...result, ...info.output.contracts }), {});
        const sourceName = Object.keys(builds).find((sourceName) => Object.keys(builds[sourceName]).find((key) => key === contractName));
        if (!sourceName)
            throw Error(`Could not find artifact for ${contractName}`);
        return builds[sourceName][contractName];
    }
    rawInput() {
        const taskInputPath = this._fileAt(this.dir(), 'input.ts');
        const rawInput = require(taskInputPath).default;
        const globalInput = { ...rawInput };
        types_1.NETWORKS.forEach((network) => delete globalInput[network]);
        const networkInput = rawInput[this.network] || {};
        return { ...globalInput, ...networkInput };
    }
    input() {
        return this._parseRawInput(this.rawInput());
    }
    output({ ensure = true, network } = {}) {
        if (network)
            this.network = network;
        const taskOutputDir = this._dirAt(this.dir(), 'output', ensure);
        const taskOutputFile = this._fileAt(taskOutputDir, this.outputFile, ensure);
        return this._read(taskOutputFile);
    }
    save(output) {
        const taskOutputDir = this._dirAt(this.dir(), 'output', false);
        if (!fs_1.default.existsSync(taskOutputDir))
            fs_1.default.mkdirSync(taskOutputDir);
        const taskOutputFile = this._fileAt(taskOutputDir, this.outputFile, false);
        const previousOutput = this._read(taskOutputFile);
        const finalOutput = { ...previousOutput, ...this._parseRawOutput(output) };
        this._write(taskOutputFile, finalOutput);
    }
    delete() {
        const taskOutputDir = this._dirAt(this.dir(), 'output');
        const taskOutputFile = this._fileAt(taskOutputDir, this.outputFile);
        fs_1.default.unlinkSync(taskOutputFile);
    }
    _parseRawInput(rawInput) {
        return Object.keys(rawInput).reduce((input, key) => {
            const item = rawInput[key];
            if (Array.isArray(item))
                input[key] = item;
            else if (ethers_1.BigNumber.isBigNumber(item))
                input[key] = item;
            else if (typeof item !== 'object')
                input[key] = item;
            else {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const output = this._isTask(item) ? item.output({ network: this.network }) : item;
                input[key] = output[key] ? output[key] : output;
            }
            return input;
        }, {});
    }
    _parseRawOutput(rawOutput) {
        return Object.keys(rawOutput).reduce((output, key) => {
            const value = rawOutput[key];
            output[key] = typeof value === 'string' ? value : value.address;
            return output;
        }, {});
    }
    _read(path) {
        return fs_1.default.existsSync(path) ? JSON.parse(fs_1.default.readFileSync(path).toString()) : {};
    }
    _write(path, output) {
        const timestamp = new Date().getTime();
        const finalOutputJSON = JSON.stringify({ ...output, timestamp }, null, 2);
        fs_1.default.writeFileSync(path, finalOutputJSON);
    }
    _fileAt(base, name, ensure = true) {
        const filePath = path_1.default.join(base, name);
        if (ensure && !this._existsFile(filePath))
            throw Error(`Could not find a file at ${filePath}`);
        return filePath;
    }
    _dirAt(base, name, ensure = true) {
        const dirPath = path_1.default.join(base, name);
        if (ensure && !this._existsDir(dirPath))
            throw Error(`Could not find a directory at ${dirPath}`);
        return dirPath;
    }
    _existsFile(filePath) {
        return fs_1.default.existsSync(filePath) && fs_1.default.statSync(filePath).isFile();
    }
    _existsDir(dirPath) {
        return fs_1.default.existsSync(dirPath) && fs_1.default.statSync(dirPath).isDirectory();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _isTask(object) {
        return object.constructor.name == 'Task';
    }
}
exports.default = Task;
